import { test } from "tap";
import { app } from "../src/app.js";
import FormData from "form-data";
import { createReadStream, readFileSync } from "fs";
import _ from "lodash";

import { awaitJobCompletion } from "./test_util/injects.js";
import generateRandomGeoFeatures from "./test_util/dataGenerator/spitRandomGeoms.js";
import { cropGeometryCoordinates } from "./test_util/cropGeometry.js";

test("standard workflow on randomly generated geodata", async (t) => {
  /* The following tests work under the assumption of valid data being generated by the randomTestDataGenerator
       and are meant to further test the standard workflow under more realistic conditions
       * Upload test for original ndjson is obsolete, this is included in the randomTestDataGenerator test.
       TODO extend this suite to include tests that check if the service behaves correctly if the data is invalid
       TODO patch collection with patchable mutated properties
       TODO patch collection with patchable original properties
       TODO todo assert collection is patched correctly
      */
  t.teardown(process.exit);
  let randomTestDataPaths: Awaited<
    ReturnType<typeof generateRandomGeoFeatures>
  >;

  t.before(async () => {
    try {
      const testData = await generateRandomGeoFeatures(
        50,
        "test/data/dynamic",
        "230619_rand_50"
      );
      randomTestDataPaths = testData;
    } catch (e) {
      console.log("error in generating random geo featues", e);
    }
  });

  t.test("uploading a valid ndjson file", async (t) => {
    const collectionId = randomTestDataPaths.collectionId;

    const mutatedDataNdjson = readFileSync(
      randomTestDataPaths.patchableMutatedPath
    ).toString();

    const mutatedForm = new FormData();
    mutatedForm.append(
      "validNdjsonData",
      createReadStream(randomTestDataPaths.patchableMutatedPath)
    );

    const mutatedPatchRes = await app.inject({
      method: "PATCH",
      url: `/collections/${collectionId}`,
      payload: mutatedForm,
      headers: mutatedForm.getHeaders(),
    });
    t.equal(
      mutatedPatchRes.statusCode,
      200,
      "patching a valid ndjson file should return 200"
    );
    // wait a second
    await awaitJobCompletion(mutatedPatchRes.body);

    // get the mutated data from db
    const mutatedDataRes = await app.inject({
      method: "GET",
      url: `/collections/${collectionId}/items`,
    });

    const mutatedData = JSON.parse(mutatedDataRes.body);

    const mutatedCompareMap = new Map();
    const ndjArray = mutatedDataNdjson.split("\n");
    ndjArray.forEach((ndj) => {
      const asJSON = JSON.parse(ndj);
      mutatedCompareMap.set(asJSON.featId, asJSON.geometry);
    });

    let allEqual = true;
    mutatedData.forEach((feature) => {
      const dbGeom = feature.Features_geom;
      const localGeom = mutatedCompareMap.get(feature.Features_feature_id);
      cropGeometryCoordinates(localGeom);
      if (!_.isEqual(dbGeom, localGeom)) {
        console.log("Mutated data is not equal to the data in the db!");
        console.log("croppedLocal: ", localGeom);
        console.log("DB: ", dbGeom);
        allEqual = false;
      }
    });
    t.equal(
      allEqual,
      true,
      "mutated data should be equal to the data in the db"
    );

    t.end();
    /*
    t.afterEach(async () => {
      await app.inject({
        method: "DELETE",
        url: `/collections/${randomTestDataPaths.collectionId}`,
      });
      // TODO check if the collection is actually deleted
    });*/
  });
});
